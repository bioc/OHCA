# Interactions-centric analysis

```{r}
#| echo: false
#| results: "hide"
#| message: false
#| warning: false
source("_common.R")
library(dplyr)
library(ggplot2)
library(GenomicRanges)
library(InteractionSet)
library(HiCExperiment)
library(HiContactsData)
library(HiContacts)
library(rtracklayer)
coolf <- HiContactsData('yeast_wt', 'mcool')
pairsf <- HiContactsData('yeast_wt', 'pairs.gz')
pf <- PairsFile(pairsf)
cf <- CoolFile(coolf)
hic <- import(cf, focus = 'II', resolution = 2000)
data(centros_yeast)
topologicalFeatures(hic, 'centromeres') <- centros_yeast
eco1_hic <- import(
    CoolFile(HiContactsData('yeast_eco1', 'mcool')), 
    focus = 'II', 
    resolution = 2000
)
eco1_pairsf <- HiContactsData('yeast_eco1', 'pairs.gz')
eco1_pf <- PairsFile(eco1_pairsf)
```

::: {.callout-note}
## Aims
This chapter focuses on the various analytical tools offered by `HiContacts`
to compute interaction-related metrics from a `HiCExperiment` object.
:::

**Interaction-centric** analyses consider a `HiCExperiment` object from the 
"interactions" perspective to perform a range of operations on genomic interactions.  
This encompasses: 

- Computing the "distance law" (a.k.a. P(s)), i.e. the distance-dependent interaction frequency
- Computing profiles of interactions between a locus of interest and the rest of the genome, (a.k.a. virtual 4C profiles)
- Computing cis/trans interaction ratios
- Computing distribution of distance-dependent interaction frequency along chromosomes, a.k.a. scalograms 

::: {.callout-note}
## Note
- Contrary to functions presented in the previous chapter, the functions 
described in this chapter are **not**: they 
take `HiCExperiment` objects as input and generally return data frames rather 
than modified `HiCExperiment` objects. 
- Internally, most of the functions presented in this chapter make a call to 
`interactions(<HiCExperiment>)` to coerce it into `GInteractions`. 
:::

::: {.callout-tip collapse="true"}
## Generating the example `hic` object ðŸ‘‡

To demonstrate `HiContacts` functionalities, we will create 
an `HiCExperiment` object from an example `.cool` file provided 
in the `HiContactsData` package. 

```{r eval = FALSE}
library(HiCExperiment)
library(HiContactsData)

# ---- This downloads example `.mcool` and `.pairs` files and caches them locally 
coolf <- HiContactsData('yeast_wt', 'mcool')
pairsf <- HiContactsData('yeast_wt', 'pairs.gz')

# ---- This creates a connection to the disk-stored `.mcool` file
cf <- CoolFile(coolf)
cf

# ---- This creates a connection to the disk-stored `.pairs` file
pf <- PairsFile(pairsf)
pf

# ---- This imports contacts from the chromosome `II` at resolution `2000`
hic <- import(cf, focus = 'II', resolution = 2000)
```

```{r}
hic
```
:::

## Distance law(s)

### P(s) from a single `.pairs` file

Distance laws are generally computed directly from `.pairs` files. This is 
because the `.pairs` files are at 1-bp resolution whereas the contact matrices 
(for example from `.cool` files) are binned at a minimum resolution. 

An example `.pairs` file can be fetched from the `ExperimentHub` database
using the `HiContactsData` package. 

```{r eval = FALSE}
library(HiCExperiment)
library(HiContactsData)
pairsf <- HiContactsData('yeast_wt', 'pairs.gz')
pf <- PairsFile(pairsf)
```

```{r}
pf
```

::: {.callout-note}
## Reminder!
`PairsFile` connections can be imported directly into a `GInteractions` object 
with `import()`: 

```{r}
import(pf)
```
:::

We can compute a P(s) per chromosome from this `.pairs` file using the `distanceLaw` function.

```{r}
library(HiContacts)
ps <- distanceLaw(pf, by_chr = TRUE) 
ps
```

::: {.callout-note icon='false'}
## Note
Because this is a toy dataset, contacts are only provided for the chromosome `II`. 

```{r}
table(ps$chr)
```
:::

The `plotPs()` and `plotPsSlope()` functions are convenient `ggplot2`-based functions
with pre-configured settings optimized for P(s) visualization.

```{r}
plotPs(ps, aes(x = binned_distance, y = norm_p))
plotPsSlope(ps, ggplot2::aes(x = binned_distance, y = slope))
```

### P(s) for multiple `.pairs` files

Let's first import a second example dataset. We'll import pairs identified in a 
*eco1* yeast mutant. 

```{r eval = FALSE}
eco1_pairsf <- HiContactsData('yeast_eco1', 'pairs.gz')
eco1_pf <- PairsFile(eco1_pairsf)
```

```{r}
eco1_ps <- distanceLaw(eco1_pf, by_chr = TRUE) 
eco1_ps
```

A little data wrangling can help plotting the distance laws for 2 different samples 
in the same plot. 

```{r}
library(dplyr)
merged_ps <- rbind(
    ps |> mutate(sample = 'WT'), 
    eco1_ps |> mutate(sample = 'eco1')
)
plotPs(merged_ps, aes(x = binned_distance, y = norm_p, color = sample)) + 
    scale_color_manual(values = c('#c6c6c6', '#ca0000'))
plotPsSlope(merged_ps, ggplot2::aes(x = binned_distance, y = slope, color = sample)) + 
    scale_color_manual(values = c('#c6c6c6', '#ca0000'))
```

### P(s) from `HiCExperiment` objects

Alternatively, distance laws can be computed from binned matrices directly by 
providing `HiCExperiment` objects. For deeply sequenced datasets, this can be significantly faster 
than when using original `.pairs` files, but the smoothness of the resulting 
curves will be greatly impacted, notably at short distances. 

```{r}
ps_from_hic <- distanceLaw(hic, by_chr = TRUE) 
plotPs(ps_from_hic, aes(x = binned_distance, y = norm_p))
plotPsSlope(ps_from_hic, ggplot2::aes(x = binned_distance, y = slope))
```

## Scalograms

```{r eval = FALSE}
### ----- scalograms
scalo <- scalogram(synthChr) 
p4 <- plotMatrix(synthChr['chrXVI-Mmmyco_inv870kb'], use.scores = 'autocorrelated', limits = c(-0.8, 0.8), scale = 'linear', cmap = bwrColors())
p5 <- plotScalogram(scalo |> filter(chr == 'chrXVI-Mmmyco_inv870kb'), ylim = c(1e3, 1e5))
p <- cowplot::plot_grid(p4, p5, align = 'hv', axis = 'tblr', rel_widths = c(1, 2)) 
p4
p5
```

## Cis/trans ratios

```{r eval = FALSE}
### ----- cis/trans ratios
ct <- cisTransRatio(synthChr) |> filter(chr != 'chrXII')
p7 <- ggplot(ct, aes(x = chr, y = trans_pct)) + 
    geom_col(position = position_stack()) + 
    theme_bw() + 
    guides(x=guide_axis(angle = 90))
p7
```

## Virtual 4C profiles

Using the mammalian NPCs dataset as an example, we can also generate virtual 
4C profiles. 

```{r NPCs_v4c, eval = FALSE}
### ----- virtual 4c (NPCs)
v4C_loop <- virtual4C(npcs_narrow, viewpoint = GRanges('chr3:100965000-100975000'), use.scores = 'balanced') |> 
    plyranges::mutate(
        score = score/sum(score),
        score = zoo::rollmean(score, k = 2, na.pad = TRUE, align = 'center'), 
        viewpoint = 'loop'
    )
v4C_TAD <- virtual4C(npcs_narrow, viewpoint = GRanges('chr3:101695000-101705000'), use.scores = 'balanced') |> 
    plyranges::mutate(
        score = score/sum(score),
        score = zoo::rollmean(score, k = 2, na.pad = TRUE, align = 'center'), 
        viewpoint = 'TAD'
    )
v4C_loop2 <- virtual4C(npcs_narrow, viewpoint = GRanges('chr3:102145000-102155000'), use.scores = 'balanced') |> 
    plyranges::mutate(
        score = score/sum(score),
        score = zoo::rollmean(score, k = 2, na.pad = TRUE, align = 'center'), 
        viewpoint = 'loop2'
    )
p8 <- plot4C(c(v4C_loop, v4C_TAD, v4C_loop2), ggplot2::aes(x = center, y = score, col = viewpoint, fill = viewpoint)) + 
    ggplot2::coord_cartesian(ylim = c(0, 0.03))
p8
```





## References {-}

::: {#refs}
:::

## Session info {-}

```{r echo = FALSE}
sessioninfo::session_info()
```
